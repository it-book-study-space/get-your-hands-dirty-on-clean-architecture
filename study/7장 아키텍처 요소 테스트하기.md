# 목차
- [7장 아키텍처 요소 테스트하기](#7장-아키텍처-요소-테스트하기)
  - [1️⃣ 테스트 피라미드](#테스트-피라미드)
    - [단위 테스트](#단위-테스트)
    - [통합 테스트](#통합-테스트)
    - [시스템 테스트](#시스템-테스트)
  - [2️⃣ 단위 테스트로 도메인 엔티티 테스트하기](#단위-테스트로-도메인-엔티티-테스트하기)
  - [3️⃣ 단위 테스트로 유스케이스 테스트하기](#단위-테스트로-유스케이스-테스트하기)
  - [4️⃣ 통합 테스트로 웹 어댑터 테스트하기](#통합-테스트로-웹-어댑터-테스트하기)
    - [왜 통합 테스트인가?](#왜-통합-테스트인가)



# 7장 아키텍처 요소 테스트하기
> 헥사고날 아키텍처에서의 테스트 전략

## 테스트 피라미드

<img src="resources/ch7img1.png" width="400px">

- 기본 전제는 만드는 비용이 적고, 유지보수하기 쉽고, 빨리 실행되며 안정적인 작은 크기의 테스트들에 대해 높은 커버리지를 유지해야 한다
- 테스트 피라미드는 테스트가 비싸질수록 테스트의 커버리지 목표는 낮게 잡아야 한다는 것을 보여준다

### 단위 테스트
- 피라미드의 토대에 해당
- 하나의 클래스를 인스턴스화하고 해당 클래스의 인터페이스를 통해 기능들을 테스트한다
- 테스트 중인 클래스가 다른 클래스에 의존한다면 의존되는 클래스들은 인스턴스화하지 않고 테스트하는 동안 mock으로 대체한다

### 통합 테스트
- 연결된 여러 유닛을 인스턴스화하고 시작점이 되는 클래스의 인터페이스로 데이터를 보낸 후 유닛들의 네트워크가 기대한대로 잘 동작하는지 검증한다

### 시스템 테스트
- 애플리케이션을 구성하는 모든 객체 네트워크를 가동시켜 특정 유스케이스가 전 계층에서 잘 동작하는지 검증한다


## 단위 테스트로 도메인 엔티티 테스트하기
- 도메인 엔티티는 가장 만들기 쉽고, 빠르게 실행되는 테스트를 만들 수 있다
- 도메인 엔티티는 다른 클래스에 거의 의존하지 않기 때문에 다른 종류의 테스트는 불필요하다

```kotlin
class AccountTest {

    @Test
    @DisplayName("계좌 금액 계산")
    fun calculatesBalance() {
        // given
        val accountId = Account.AccountId(1L)
        val account = defaultAccount(
            accountId = accountId,
            baselineBalance = Money.of(555L),
            activityWindow = ActivityWindow(
                defaultActivity(
                    targetAccountId = accountId,
                    money = Money.of(999L)
                ),
                defaultActivity(
                    targetAccountId = accountId,
                    money = Money.of(1L)
                )
            )
        )

        // when
        val balance = account.calculateBalance()

        // then
        assertThat(balance).isEqualTo(Money.of(1555L))
    }

    // ...
}
```

## 단위 테스트로 유스케이스 테스트하기


## 통합 테스트로 웹 어댑터 테스트하기
- 웹 어댑터 테스트는 HTTP 를 통해 입력을 받고, 입력에 대한 유효성 검증, 유스케이스에서 사용할 수 있는 포맷으로 매핑, 유스케이스에 전달하고 다시 결과를 JSON으로 매핑하는 과정들이 테스트 되어야 한다
- `MockMvc` 객체를 이용해 모킹했기 때문에 실제로 HTTP 프로토콜을 통해 테스트 한 것은 아니다
  - 프레임워크가 HTTP 프로토콜에 맞게 모든 것을 잘 변환한다고 믿는 것

### 왜 통합 테스트인가?
> 하나의 웹 컨트롤러 클래스만 테스트한 것처럼 보이지만, 실제로는 보이지 않는 곳에서 더 많은 일들이 수행되고 있음

- Spring 에서는 `@WebMockTest` 어노테이션을 사용하여 스프링이 특정 요청 경로, 자바와 JSON 간의 매핑, HTTP 입력 검증 등에 필요한 전체 객체 네트워크를 인스턴스화하도록 만든다


```kotlin
@WebMvcTest(controllers = [SendMoneyController::class])
class SendMoneyControllerTest {

    @Autowired
    private lateinit var mockMvc: MockMvc

    @MockitoBean
    private lateinit var sendMoneyUseCase: SendMoneyUseCase

    @Test
    @DisplayName("송금 테스트")
    fun testSendMoney() {
        mockMvc.perform(
            post("/accounts/send/{sourceAccountId}/{targetAccountId}/{amount}", 41L, 42L, 500)
                .header("Content-Type", "application/json")
        )
            .andExpect(status().isOk)

        verify(sendMoneyUseCase).sendMoney(
            SendMoneyCommand(
                sourceAccountId = Account.AccountId(41L),
                targetAccountId = Account.AccountId(42L),
                money = Money.of(500L)
            )
        )
    }
}
```